1. 쿠키와 세션의 차이에 대해 설명해주세요.

- 답변
  - 쿠키는 클라이언트의 로컬, 세션은 서버에 저장
  - 보안성 : 쿠키 < 세션
    - 쿠키는 웹서버에서 전송할 때 같이 전송되므로, 누군가 훔쳐볼 우려가 있지만 세션은 쿠키를 통해 세션 아이디만 저장하고, 서버에서 처리하기 때문에 보안성이 더 우수.
  - 속도 : 쿠키 > 세션
    - 로컬에서 저장된 데이터를 전송하는게, 서버를 통한 저장소 보다는 빠르다.
  - 라이프사이클
    - 쿠키는 브라우저를 종료해도 만료기간이 남으면 존재
    - 세션은 브라우저가 종료되면 만료기간 상관없이 종료됨

2. 페이지 교체에 대해 설명해주세요.

- 답변
  - 프로세스의 주소 공간에는 존재하지만, 지금 컴퓨터의 RAM 에 없는 데이터에 접근했을 경우 발생하는 페이지 폴트가 일어나면, 메인 메모리에 있으면서 사용하지 않는 페이지를 디스크로 내보내고, 새로운 페이지로 바꾸는 과정을 뜻한다.
  - 이 때, 페이지 폴트가 많이 일어나지 않도록 많이 참조되는 페이지를 Swap-in 하고 많이 참조하지 않는 페이지를 Swap-out 하도록 해야 하는데, 이 방법을 페이지 교체 알고리즘을 통해 선택한다.

3. 캐시의 지역성 원리에 대해 설명해주세요.

- 답변
  - CPU의 메모리 접근이 균등하지 않다는 가정으로, 메모리 접근에 특성이 존재하기 때문에 캐시 메모리는 이러한 점을 반영하여 메모리에서 미리 일부 데이터를 가져와 저장합니다.최근 접근한 메모리에 접근하려는 경향을 반영하는 시간 지역성, 접근한 메모리와 인접한 메모리에 접근하려는 경향을 반영하는 공간 지역성이 있습니다.

4. 페이지 폴트란 무엇인지 설명해주세요.

- 답변
  - 프로세스가 페이지를 요청했을때 그 페이지가 메모리에 없는 경우를 페이지 폴트라고 한다. 페이지 폴트가 발생하면 프레임을 새로 할당 받아야 하며, 프로세스가 해당 페이지를 사용할 수 있도록 스왑 영역에서 메인 메모리로 옮겨야 한다. 그리고 페이지 테이블을 재구성하고 프로세스 작업을 재시작한다.

5. TLB의 개념에 대해 설명하고, TLB miss와 TLB hit가 일어나는 경우에 대해서 설명해주세요.

- 답변
  - TLB는 Page Table 자체가 메인 메모리에 있기 때문에 그것의 속도 차 때문에 떨어지는 성능을 막기 위한 일종의 캐시다. TLB는 적은 수의 페이지 테이블만을 포함하고 있다. CPU에 의해 논리적 주소가 생성될때 그 주소의 페이지 번호가 TLB에 제시된다.
  - 만약 그 페이지 번호가 TLB에서 발견된다면(TLB hit) 해당하는 프레임은 즉시 사용가능해지며 메모리에 접근할 수 있다. 하지만 만약 페이지 번호가 TLB에서 발견되지 않았다면(TLB miss) 그 페이지 테이블에 대한 메모리 참조가 만들어져야 한다. 페이지 번호에 대응하는 프레임 번호는 TLB에 저장하여, 다음에 해당 페이지를 참조할때 빠르게 메모리에 접근한다.

6. 운영체제의 역할은 무엇인가요?

- 답변
  - CPU 스케줄링과 프로세스 관리
    - CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환을 관리
  - 메모리 관리
    - 한정된 메모리를 어떤 프로세스에 얼만큼 할당해야 하는지 관리
  - 디스크 파일 관리
    - 디스크 파일을 어떠한 방법으로 보관할지 관리
  - I/O 디바이스 관리
    - 마우스, 키보드와 컴퓨터 간에 데이터를 주고받는 것을 관리

7. 페이징과 세그먼테이션 비교 설명

- 답변
  - 페이징
    - 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당
    - 홀의 크기가 균일하지 않은 문제가 없어지지만 주소 변환이 복잡해짐
  - 세그멘테이션
    - 페이지 단위가 아닌 의미 단위인 세그먼트로 나누는 방식
    - 코드, 데이터, 스택, 힙 등으로 프로세스가 이루어짐
    - 코드와 데이터 등 이를 기반으로 나눌 수 있음
    - 함수 단위로 나눌 수도 있음
    - 공유와 보안 측면에서 좋으며 홀 크기가 균일하지 않은 문제가 발생

8. 고정 분할 방식과 가변 분할 방식

- 답변

  - 둘다 메모리에 연속적으로 할당하는 연속할당
  - 메모리를 미리 나누어 관리하는 고정 분할 방식
  - 매 시점 프로그램의 크기에 맞게 메모리를 분할하여 사용하는 가변 분할 방식

  - 고정 분할 방식 (fixed partition allocation)
    - 메모리를 미리 나누어 관리하는 방식
    - 미리 나뉘어 있어서 융통성이 없음
    - 내부 단편화 발생
  - 가변 분할 방식 (variable partition allocation)
    - 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용
    - 외부 단편화 발생
    - 최초적합 (first fit)
      - 위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당
    - 최적적합 (best fit)
      - 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당
    - 최악적합 (worst fit)
      - 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당

9. PCB에 대해서 설명해주세요.

- 답변
  - PCB(Process Control Block)는 운영체제에서 프로세스에 대한 메타데이터를 저장한 ‘데이터’
  - 프로세스 제어 블록이라고도 함
  - 프로세스가 생성되면 운영체제는 해당 PCB를 생성
  - 프로그램이 실행되면 프로세스가 생성되고 프로세스 주소 값들에 앞서 설명한 스택, 힙 등의 구조를 기반으로 메모리가 할당됨
  - 이 프로세스의 메타데이터들이 PCB에 저장되어 관리됨
  - 이는 프로세스의 중요한 정보를 포함하고 있기 때문에 일반 사용자가 접근하지 못하도록 커널 스택의 가장 앞부분에서 관리됨

10. 멀티프로세싱의 장점에 대해서 설명해주세요.

- 답변
  - 독립된 구조로 안전성이 높음
  - 프로세스 중 하나에 문제가 생겨도 다른 프로세스에 영향을 주지 않아, 작업속도가 느려지는 손해 정도는 생기지만 정지되거나 하는 문제는 발생하지 않음
  - 여러 개의 프로세스가 처리되어야 할 때 동일한 데이터를 사용하고, 이러한 데이터를 하나의 디스크에 두고 모든 프로세서(`CPU`)가 이를 공유하면 비용적으로 저렴함

11. 시스템 콜에 대해 간단히 설명해주세요.

- 답변
  - 시스템 콜은 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스입니다.

12. 유저모드와 커널모드 차이점에 대해 설명해주세요.

- 유저모드 : 유저가 접근할 수 있는 영역을 제한적으로 두어
  컴퓨터 자원에 함부로 침범하지 못하는 모드
- 커널모드 : 모든 컴퓨터 자원에 접근할 수 있는 모드

13. 로컬 스토리지와 세션스토리지 공통점과 차이점

- 공통점 : 클라이언트 기반 키-밸류 저장소
- 차이점은 영구성과 범위에 있어서 크게 차이가 납니다.
  - 로컬 스토리지 ( Local Storage ) 는 브라우저를 종료해도 데이터를 보관(영구성)합니다.
    또한, 도메인만 같으면 전역적으로 데이터가 공유되는 특성을 가지고 있습니다.
    하지만, 세션 스토리지 ( Session Storage ) 는 브라우저가 종료되면 데이터가 삭제(비영구성)됩니다.
    도메인이 같더라도 브라우저가 다르면 ( 탭 브라우저, 다른 브라우저 ) 브라우저 컨택스트가 다르기 때문에
    각각의 세션 스토리지가 형성되어 데이터 공유가 되지 않습니다.

14. 프로세스와 스레드의 차이점에 대해 설명해주세요.

- 프로세스
  - 메모리 상에서 실행중인 프로그램을 말하며, 스레드는 이 프로세스 안에서 실행되는 흐름 단위를 말한다.
  - 최소 하나의 스레드를 보유하고 있으며, 각각 별도의 주소공간을 독립적으로 할당 받는다. (code, heap, stack)
- 스레드
  - stack만 따로 할당받고 나머지 영역은 스레드끼리 서로 공유한다.

15. 문맥 교환 ( Context Switch )에 대해 간단히 설명해주세요.

- CPU를 어떤 프로세스에서 다른 프로세스로 넘겨주며 PCB를 저장하고 로드하는 과정이다.

16. 문맥교환이 일어나는 상황은 무엇이 있나요?

- Timer interrupt 가 들어온 경우 (할당된 시간이 다 된 경우)
- I/O 요청 System call이 들어온 경우

17. 교착상태의 발생 조건 4가지에 대해 설명해주세요.

- 교착상태는 상호배제, 점유 대기, 비선점, 환형 대기 4가지 조건이 모두 충족해야 발생할 가능성이 있으며, 하나라도 만족하지 않으면 교착상태가 발생하지 않습니다.
- 한 프로세스가 자원을 독점하고 있으며 다른 프로세스가 이에 접근이 불가능한 상태이고, 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하고 있으며, 다른 프로세스의 자원을 강제적으로 가져올 수 없는 비선점방식이면서 서로가 서로의 자원을 요구하고 있는 상황에 발생 가능합니다.

18. 교착 상태의 해결 방법

- 교착 상태를 해결하는 방법에는 예방, 회피, 탐지, 복구 방법이 있습니다.
- 자원을 할당할 때 애초에 발생 조건이 성립되지 않도록 설계 하는 방법, 교착 상태 가능성이 없을 때만 자원을 할당하도록 회피하는 방법이 있습니다. 회피방법에서는 은행원 알고리즘을 사용할 수 있습니다. 또한, 교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한개 씩 지우는 방법과 교착 상태가 발생하면 사용자가 작업을 중단하는 방법이 있습니다. 교착 상태는 매우 드물게 일어나기 때문에 이를 처리하는 비용이 더 커서 현재는 마지막 체제를 사용하고 있습니다.

19. 뮤텍스와 세마포어의 차이에 대해서 설명해주세요

- 가장 큰 차이점은 동기화 대상의 개수입니다.
- Mutex는 동기화 대상이 오직 1개일 때 사용하며, Semaphore는 동기화 대상이 1개 이상일 때 사용합니다.
- Mutex는 자원을 소유할 수 있고, 책임을 가지는 반면 Semaphore는 자원 소유가 불가합니다.
- Mutex는 상태가 0, 1 뿐이므로 Lock을 가질 수 있고, 소유하고 있는 스레드만이 이 Mutex를 해제할 수 있습니다. 반면 Semaphore는 Semaphore를 소유하지 않는 스레드가 Semaphore를 해제할 수 있습니다.
- Semaphore는 시스템 범위에 걸쳐 있고, 파일 시스템 상의 파일로 존재합니다. 반면, Mutex는 프로세스의 범위를 가지며 프로세스 종료될 때 자동으로 Clean up 됩니다.
